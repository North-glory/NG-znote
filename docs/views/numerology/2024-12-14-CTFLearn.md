---
title: 20241214CTF学习笔记11
date: 2024-12-14
tags:
 - CTF
 - CTFLearn
categories:
   - 命理学 Numerology
isShowComments: true
publish: true










---

<Boxx/>

从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第28天

[[toc]]

- 视频地址【[🔗传送门](https://www.bilibili.com/video/BV1Lh411F7s8/)】

<!-- more -->

# 第12章：布尔盲注2

## 书接上回


我们使用ascii()函数的好处是：

1. 可以免除乱七八糟的符号的干扰
2. 让right等函数本来不是精确的截取变成了精确的截取
3. 字符转换为数字后，能进行大于号、小于号的比较

```mysql
mysql> select ascii(right('abcdef',4))>1;
+----------------------------+
| ascii(right('abcdef',4))>1 |
+----------------------------+
|                          1 |
+----------------------------+
1 row in set (0.00 sec)

mysql> select ascii(right('abcdef',4))>100;
+------------------------------+
| ascii(right('abcdef',4))>100 |
+------------------------------+
|                            0 |
+------------------------------+
1 row in set (0.00 sec)

mysql> select ascii(right('abcdef',4))>50;
+-----------------------------+
| ascii(right('abcdef',4))>50 |
+-----------------------------+
|                           1 |
+-----------------------------+
1 row in set (0.00 sec)
```

我们可以用大于、小于做比较，用二分查找来找到目标的字母。

如果我们用字符来比较的话，逐个比较比较浪费时间，转为ascii后用二分查找要大大节省时间和流量



### 如果ascii()函数被过滤了怎么办？

如果ascii()函数被过滤了，我们可以使用ascii的同名函数`ord()`



## left()函数

`left()`函数的使用方法基本和`right()`函数相同，`left(str,len)`，和`right()`不同的点在于是从左截取，导致首字母一直是第一个字母不变，不能用`ascii()`的函数，但有天才想出来可以用resverse()函数，将left的结果倒过来，倒过来以后就能用ascii码了。

```
mysql> select left('abc',1);
+---------------+
| left('abc',1) |
+---------------+
| a             |
+---------------+
1 row in set (0.00 sec)

mysql> select left('abc',2);
+---------------+
| left('abc',2) |
+---------------+
| ab            |
+---------------+
1 row in set (0.00 sec)

mysql> select left('abc',3);
+---------------+
| left('abc',3) |
+---------------+
| abc           |
+---------------+
1 row in set (0.00 sec)

mysql> select reverse(left('abc',3));
+------------------------+
| reverse(left('abc',3)) |
+------------------------+
| cba                    |
+------------------------+
1 row in set (0.00 sec)
```



## trim()函数



### 定义：

trim()函数：过滤指定的字符串，最常见的用途是移除字首或字尾的空白。



### 同类型的函数：

在MySQL中：TRIM()、LTRIM()、RTRIM()

- TRIM()删除前后空格
- LTRIM()删除字符串结尾空格
- RTRIM()删除字符串起始空格



### 其他用法：

BOTH前后都移除，LEADING移除前面的，TRAILING移除后边的。

```mysql
trim([BOTH/LEADING/TRAILING] 目标字符串 FROM 源字符串)
```

举例：

```
mysql> select trim(leading 'a' from 'abcd');
+-------------------------------+
| trim(leading 'a' from 'abcd') |
+-------------------------------+
| bcd                           |
+-------------------------------+
1 row in set (0.00 sec)

mysql> select trim(leading 'b' from 'abcd');
+-------------------------------+
| trim(leading 'b' from 'abcd') |
+-------------------------------+
| abcd                          |
+-------------------------------+
1 row in set (0.00 sec)
```

以上结果表明，如果用leading这种移除只能移除开头是指定字符的，此时我们可以加一些技巧，让他可以精确的截取（这个技巧简直是天才的想法）

```mysql
# I表示一个字符的意思，比如I=a，则I+1=b，I+2=c
# 设I=x，I+1是y，字符串只有确定的一个字符是起始，所以对两个的trim leading进行比较
# xy如果都不是起始，等于号左右两边都是abcd，比较后会返回1，如果xy中有一个是起始，这个比较就会返回0
trim(leading I from 'abcd') = trim(leading I+1 from 'abcd')

# 循环执行上一步，抽象理解我们的结果锁定在了I和I+1这两者之间，我们对I+1和I+2再进行一次比较
# 如果说I+1和I+2的trim相等了，说明首字符就是I，如果I+1和I+2不相等，说明首字符是I+1
trim(leading I+2 from 'abcd') = trim(leading I+1 from 'abcd')
```

类似的，我们用trim还有多种方法能做精确的截取，比如`trim i`和`trim i+1`比较长度，或者是和源字符串进行比较，所以刚才列举的方法并不是唯一的方法。



## 比较

### 等于

```mysql
select substr(database(),1,1)='a'
```



### 大于 小于

```
mysql> select 2>1;
+-----+
| 2>1 |
+-----+
|   1 |
+-----+
1 row in set (0.00 sec)

mysql> select 'b'>'a';
+---------+
| 'b'>'a' |
+---------+
|       1 |
+---------+
1 row in set (0.00 sec)
```

特别需要注意的是：在比较字符串的时候，看的只是首字符

```mysql
mysql> select 'b'>'abcdef';
+--------------+
| 'b'>'abcdef' |
+--------------+
|            1 |
+--------------+
1 row in set (0.00 sec)

mysql> select 'b'>'cdef';
+------------+
| 'b'>'cdef' |
+------------+
|          0 |
+------------+
1 row in set (0.00 sec)
```



### Like模糊匹配

> 在 MySQL 中，`LIKE`是一个用于模糊匹配的关键字，主要用于在`SELECT`、`UPDATE`、`DELETE`等语句中对字符型数据进行模式匹配。它可以帮助你查找那些满足某种模糊条件的记录，例如查找所有以某个字符开头或者包含某个字符的字符串。使用百分号`%`来表示任意字符，使用下划线`_`表示单个字符。

```
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| base               |
| sys                |
| tale               |
| test               |
+--------------------+
.. rows in set (0.01 sec)

mysql> select database() like 't%';
+----------------------+
| database() like 't%' |
+----------------------+
|                    1 |
+----------------------+
1 row in set (0.00 sec)

mysql> select database() like 'a%';
+----------------------+
| database() like 'a%' |
+----------------------+
|                    0 |
+----------------------+
1 row in set (0.00 sec)
```

通过以上案例可以了解到一些特性，这样返回的结果是一个布尔值，只能表示`有或没有`

```
mysql> select 1 like '1';
+------------+
| 1 like '1' |
+------------+
|          1 |
+------------+
1 row in set (0.00 sec)

mysql> select 1 like 1;
+----------+
| 1 like 1 |
+----------+
|        1 |
+----------+
1 row in set (0.00 sec)
```

🙋‍♂️通过以上案例可以看到，当使用`LIKE`操作符时，数字会被隐式地转换为字符类型，然后再进行模式匹配

🙋‍♂️如果没有使用百分号%，LIKE子句与等于号`=`是一样的。

### 正则表达式 regexp/rlike

如果我们有个test的数据库，而我们执行以下语句，得到结果为真

```
mysql> select database() regexp '^te';
+-------------------------+
| database() regexp '^te' |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.00 sec)
```

需要注意的是，regexp是不区分大小写的，需要大小写敏感的话需要加上binary关键字

```
mysql> select binary database() rlike '^tes';
+--------------------------------+
| binary database() rlike '^tes' |
+--------------------------------+
|                              1 |
+--------------------------------+
1 row in set (0.00 sec)

mysql> select binary database() rlike '^Tes';
+--------------------------------+
| binary database() rlike '^Tes' |
+--------------------------------+
|                              0 |
+--------------------------------+
1 row in set (0.00 sec)
```



### 范围比较关键字Between

expr [NOT] BETWEEN bgin_expr AND end_expr;

- `between`筛选的是`expr>=begin_expr`并且`expr<=end_expr`的数据，如果不存在则返回的是0；
- `not between`筛选的是`expr<begin_expr`或者`expr>endexpr`的数据，如果不存在则返回的是0；
- 如果`expr`返回的是`NULL`，则`between`返回的也是`NULL`；

```mysql
mysql> select 2 between 1 and 3;
+-------------------+
| 2 between 1 and 3 |
+-------------------+
|                 1 |
+-------------------+
1 row in set (0.00 sec)

mysql> select 2 between 2 and 2;
+-------------------+
| 2 between 2 and 2 |
+-------------------+
|                 1 |
+-------------------+
1 row in set (0.00 sec)
```

不建议用`between 2 and 3`，这样符合条件的有多个，因为是闭区间，完全可以限定死只能是`between 2 and 2`



### IN 关键字

in对大小写也不敏感，字符和数字都可以用in，同样我们也有not in

```
mysql> select 'a' in('a','b','c');
+---------------------+
| 'a' in('a','b','c') |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 1 in (1);
+----------+
| 1 in (1) |
+----------+
|        1 |
+----------+
1 row in set (0.00 sec)

mysql> select 'a' in ('A');
+--------------+
| 'a' in ('A') |
+--------------+
|            1 |
+--------------+
1 row in set (0.00 sec)

mysql> select binary 'a' in('A');
+--------------------+
| binary 'a' in('A') |
+--------------------+
|                  0 |
+--------------------+
1 row in set (0.00 sec)
```



### And逻辑与运算符

- 1与任何字符and运算都是0
- 1与任何非0数字and运算都是1

```
mysql> select 1 and '0';
+-----------+
| 1 and '0' |
+-----------+
|         0 |
+-----------+
1 row in set (0.00 sec)

mysql> select 1 and 0;
+---------+
| 1 and 0 |
+---------+
|       0 |
+---------+
1 row in set (0.00 sec)

mysql> select 1 and ascii('a');
+------------------+
| 1 and ascii('a') |
+------------------+
|                1 |
+------------------+
1 row in set (0.00 sec)
```

`&&`：这是逻辑与运算 和and一样

`&`：这是按位与运算

```
mysql> select 1 and ascii('a')-96;
+---------------------+
| 1 and ascii('a')-96 |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 1 and ascii('a')-97;
+---------------------+
| 1 and ascii('a')-97 |
+---------------------+
|                   0 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 1 and ascii('a')-98;
+---------------------+
| 1 and ascii('a')-98 |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)
```

由以上案例我们可以在盲注中用and来判读， ascii('a')-97做了and判断后结果显示0，说明字符是chr(97)



### or或运算

- `||`等价于or
- `|`是按位或

```mysql
mysql> select 0 or ascii('a')-96;
+--------------------+
| 0 or ascii('a')-96 |
+--------------------+
|                  1 |
+--------------------+
1 row in set (0.00 sec)

mysql> select 0 or ascii('a')-97;
+--------------------+
| 0 or ascii('a')-97 |
+--------------------+
|                  0 |
+--------------------+
1 row in set (0.00 sec)

mysql> select 0 or ascii('a')-98;
+--------------------+
| 0 or ascii('a')-98 |
+--------------------+
|                  1 |
+--------------------+
1 row in set (0.00 sec)
```



### 异或

- `Xor`逻辑异或
- `^`按位异或

```
mysql> select 1^1^1;
+-------+
| 1^1^1 |
+-------+
|     1 |
+-------+
1 row in set (0.00 sec)

mysql> select 1^0^1;
+-------+
| 1^0^1 |
+-------+
|     0 |
+-------+
1 row in set (0.00 sec)
```

```
mysql> select 1^(ascii('a')-96)^1;
+---------------------+
| 1^(ascii('a')-96)^1 |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql> select 1^(ascii('a')-97)^1;
+---------------------+
| 1^(ascii('a')-97)^1 |
+---------------------+
|                   0 |
+---------------------+
1 row in set (0.00 sec)
```

异或有一个著名的注入方法：异或注入

当题目不允许使用❌❌❌注释符❌❌❌的时候，需要用到异或注入

以前我们用以下方式注入，加粗字体即为我们的输入

where id = ' **1' and 1=1 -- **'	或where id = ' **1' and 1=1 #**'

不用注释符号的话，我们可以用以下方法绕过

where id = '**1'^(substr()='a')^'1**'

在上述条件中，我们中间用到了一个布尔表达式，用字“符串截取和比较这”两个部分来组成，这个表达式会返回1或者0，这个1或者0影响着异或的结果。

同样我们除了^异或符号以外，还可以用等于号

```mysql
mysql> select '1'=(1=1)='1';
+---------------+
| '1'=(1=1)='1' |
+---------------+
|             1 |
+---------------+
1 row in set (0.00 sec)

mysql> select '1'=(1=2)='1';
+---------------+
| '1'=(1=2)='1' |
+---------------+
|             0 |
+---------------+
1 row in set (0.00 sec)

mysql> select '1'^(1=1)^'1';
+---------------+
| '1'^(1=1)^'1' |
+---------------+
|             1 |
+---------------+
1 row in set (0.00 sec)

mysql> select '1'^(1=2)^'1';
+---------------+
| '1'^(1=2)^'1' |
+---------------+
|             0 |
+---------------+
1 row in set (0.00 sec)
```



### 拓展

#### **异或定义：**

在 MySQL 中，异或（`^`）是一个逻辑运算符，用于对两个布尔值（真或假）或两个整数的二进制位进行操作。

1. **布尔值的异或操作规则**：当两个布尔值不同时，结果为真（`1`）；当两个布尔值相同时，结果为假（`0`）。例如，`true ^ false`的结果是`true`，`false ^ false`的结果是`false`
2. **整数二进制位的异或操作规则**：对两个整数的二进制表示逐位进行异或操作。当对应的二进制位不同时，结果位为`1`；当对应的二进制位相同时，结果位为`0`。例如，对于整数`5`（二进制为`101`）和`3`（二进制为`011`），`5 ^ 3`的计算过程是`101 ^ 011 = 110`（二进制），转换为十进制是`6`。

#### **分析`SELECT 1^1^1;`的运算过程**

首先，计算1^1

1. 数字 1 的二进制表示是`0001`（为了方便说明，这里以 4 位二进制为例，实际在计算机中根据数据类型的不同长度会有所不同）。
2. 那么`1^1`就是`0001 ^ 0001`，按照异或规则，相同位为 0，所以结果是`0000`，转换为十进制就是 0。

然后，计算0^1

（上一步的结果 0 和最后一个 1 进行异或）

- 0 的二进制表示是`0000`，1 的二进制表示是`0001`。
- 进行异或操作`0000 ^ 0001`，不同位为 1，结果是`0001`，转换为十进制就是 1。

如果用布尔值来理解的话：

- 在 MySQL 中，布尔值的真可以用 1 表示，假可以用 0 表示。当把 1 看作布尔值（即真）时，异或运算规则是两个布尔值不同时结果为真（1），相同时结果为假（0）。
- 对于`SELECT 1^1^1`，先看前两个 1 的异或：1（真）^ 1（真），根据布尔值异或规则，结果为假（0）。然后再用这个结果（0，看作假）与最后一个 1（真）进行异或，0（假）^ 1（真），结果为真（1）。



