---
title: 20241215CTF学习笔记12
date: 2024-12-15
tags:
 - CTF
 - CTFLearn
categories:
   - 命理学 Numerology
isShowComments: true
publish: true











---

<Boxx/>

从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第29天

[[toc]]

- 视频地址【[🔗传送门](https://www.bilibili.com/video/BV1Lh411F7s8/)】

<!-- more -->

# 第13章：延时盲注

> 延时盲注考的不太多
>
> 大概算了一下，这个视频系列有100集，如果按照每天1集的速度，学完至少要三个月，太慢了，需要加快速度了。

## 适用场景：

如果现在不给返回布尔型的状态了，比如“登录成功”、“登录失败”。现在都返回的是查询成功，这种情况下用延时盲注

### if方法延时盲注

```
mysql> select if(1=1,1,0);
+-------------+
| if(1=1,1,0) |
+-------------+
|           1 |
+-------------+
1 row in set (0.00 sec)
```

```
mysql>  select if(1=1,sleep(5),0);
+--------------------+
| if(1=1,sleep(5),0) |
+--------------------+
|                  0 |
+--------------------+
1 row in set (5.01 sec)
```

一般形式：if(exp1,exp2,exp3)

意思是，如果表达式1成立，就返回表达式2，否则就返回表达式3。

### Case方法延时忙注

```
mysql> select case 'a' when 'a' then 1 else 0 end;
+-------------------------------------+
| case 'a' when 'a' then 1 else 0 end |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select case when 'a'='a' then 1 else 0 end;
+-------------------------------------+
| case when 'a'='a' then 1 else 0 end |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)
```

一般形式：case exp1 when exp2

case when then 有两种写法

- 一种是案例1的case一个字符，when一个字符
- 一种是案例2的case什么也不加，when一个表达式

### 延时的基本方法

用`sleep()`函数，括号里单位是秒

我们只需要构造case或者if条件表达式，然后满足条件就让他延时，看网页加载的长短就能观察出延时成功了还是没成功，进而可以判断出条件表达式的真假，通过表达式的真假就可以把数据给注入出来（简直天才的想法）

### 其他方法

如果过滤了sleep()同时又没有回显，只能延时注入，该怎么办？

ps：mysql中只有sleep这一个延时函数。

**解决方案：**

1. `benchmark()`：这个函数可以测试某些特定操作的执行速度，参数可以是需要执行的次数和表达式，表达式可以是任何的标量表达式，比如返回值是标量的子查询或者函数，该函数可以很方便地测试某些特定操作的性能，比如通过测试可以发现，MD5()函数要比SHA1()函数要快。

   ```mysql
   mysql> select benchmark(1000000,md5('Flag'));
   +--------------------------------+
   | benchmark(1000000,md5('Flag')) |
   +--------------------------------+
   |                              0 |
   +--------------------------------+
   1 row in set (0.13 sec)
   
   mysql> select benchmark(1000000,sha1('Flag'));
   +---------------------------------+
   | benchmark(1000000,sha1('Flag')) |
   +---------------------------------+
   |                               0 |
   +---------------------------------+
   1 row in set (0.48 sec)
   ```

2. **笛卡尔积：**主要用count()函数，一般是用`count(*)`或者`count(1)`，又或者count(列名)。根据列是不是主键而会影响到性能。

   ```mysql
   mysql> select count(*) from account;
   +----------+
   | count(*) |
   +----------+
   |        1 |
   +----------+
   1 row in set (0.02 sec)
   
   mysql> select * from account;
   +-----+-------+---------+
   | aid | name  | balance |
   +-----+-------+---------+
   |   1 | admin |       1 |
   +-----+-------+---------+
   1 row in set (0.00 sec)
   
   mysql> select count(*) from account A,account B;
   +----------+
   | count(*) |
   +----------+
   |        1 |
   +----------+
   1 row in set (0.00 sec)
   ```

3. `get_lock`：这是一种比较神奇的利用技巧，延时是精确可控的，但问题在于并不是所有的站都适用

   ```
   mysql> select get_lock('flag',1);
   +--------------------+
   | get_lock('flag',1) |
   +--------------------+
   |                  1 |
   +--------------------+
   1 row in set (0.00 sec)
   
   # 此时我们重新开个窗口，需要换个session
   mysql> select get_lock('flag',5);
   +--------------------+
   | get_lock('flag',5) |
   +--------------------+
   |                  1 |
   +--------------------+
   1 row in set (5.02 sec)
   
   ```

   在一个session中可以先锁定一个变量，然后通过另一个session再次执行get_lock函数，此时会产生5秒的延迟，其效果类似于sleep(5)，当然之后可以用re`RELEASE_LOCK()`函数释放

4. **正则表达式：**正则表达式在匹配较长的字符串但自由度比较高的字符串时，会造成较大的计算量，我们通过rpad或者repeat构造长字符串，加以计算量大的pattern，通过控制字符串长度我们可以控制延时。

   ```
   mysql> select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');
   +-------------------------------------------------------------+
   | rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b') |
   +-------------------------------------------------------------+
   |                                                        NULL |
   +-------------------------------------------------------------+
   1 row in set, 1 warning (0.00 sec)
   ```

   

以上延时都考的挺少的。



# 第14章：报错盲注

## 报错盲注

### 一般形式

`if error , return ERR `

`ELSE return OK!`



### 举例引入问题：

```mysql
if((substr='a'), 执行某个函数执行过程中报错, 0)
```

这个函数执行过程中报错，可不是随便自己起一个乱七八糟的函数名就可以的，这样只会在select一执行就报错。

我们可以使用两种函数：exp()和cot()



### exp()函数：

作用：会返回自然对数，也就是e的多少次方。

```mysql
mysql>  select if(1=1,sleep(5),0);
+--------------------+
| if(1=1,sleep(5),0) |
+--------------------+
|                  0 |
+--------------------+
1 row in set (5.01 sec)

mysql> select exp(1);
+-------------------+
| exp(1)            |
+-------------------+
| 2.718281828459045 |
+-------------------+
1 row in set (0.00 sec)

mysql> select exp(5);
+-------------------+
| exp(5)            |
+-------------------+
| 148.4131591025766 |
+-------------------+
1 row in set (0.00 sec)

mysql> select exp(500);
+------------------------+
| exp(500)               |
+------------------------+
| 1.4035922178528375e217 |
+------------------------+
1 row in set (0.00 sec)

mysql> select exp(5000);
ERROR 1690 (22003): DOUBLE value is out of range in 'exp(5000)'
```

我们有了以上exp函数，我们可以试一下if里边用exp

```mysql
mysql> select if((1=1),exp(5000),0);
ERROR 1690 (22003): DOUBLE value is out of range in 'exp(5000)'
mysql> select if((1=2),exp(5000),0);
+-----------------------+
| if((1=2),exp(5000),0) |
+-----------------------+
|                     0 |
+-----------------------+
1 row in set (0.00 sec)
```



### cot()三角函数

这个可以直接用`select cot(0)`

```mysql
mysql> select cot(0);
ERROR 1690 (22003): DOUBLE value is out of range in 'cot(0)'
```

> 余切函数\(\cot(x)\)的表达式为： 
> $$
> [ \cot(x)=\frac{\cos(x)}{\sin(x)} ]
> $$
> 当(x = 0)时，sin(0)=0，此时按照余切函数的定义式
> $$
> \cot(0)=\frac{\cos(0)}{\sin(0)}
> $$
> 由于分母sin(0) = 0，而在数学运算里，除数是不能为0的，因为这样的除法运算没有意义，所以cot(0)是没有定义的，不能进行这样的运算。 