---
title: 20241218CTF学习笔记14
date: 2024-12-18
tags:
 - CTF
 - CTFLearn
categories:
   - 命理学 Numerology
isShowComments: true
publish: true













---

<Boxx/>

从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第31天

[[toc]]

- 视频地址【[🔗传送门](https://www.bilibili.com/video/BV1Lh411F7s8/)】

<!-- more -->

# 第16章：初识反序列化

## 1.反序列化

10大最常出现的漏洞：owasp top 10

> 1. **A01:2021 - 访问控制失效**：从 2017 年版的第五位上升至首位，是最严重的 Web 应用程序安全风险之一。例如，用户能够访问未授权的页面或执行未授权的操作，平均有 3.81% 的受测应用程序存在此风险，与该风险类别对应的 34 个常见弱点枚举（CWE）在应用程序中的出现次数比其他任何类别都多。
> 2. **A02:2021 - 加密失效**：由 2017 年版的敏感数据暴露更名而来，重点关注与加密相关的故障，如使用不安全的加密算法、密钥管理不当等，常导致敏感数据暴露或系统受损，在此次排名中上升至第 2 位 。
> 3. **A03:2021 - 注入**：在 2021 版中下滑至第 3 位，不过 94% 的应用程序都针对某种形式的注入进行了测试，与该类别对应的 33 个 CWE 在应用程序中的出现次数位居第二，且此版本中跨站脚本攻击也被纳入该类别。
> 4. **A04:2021 - 不安全设计**：作为 2021 年的新类别，重点关注与设计缺陷相关的风险。若想从根本上提高安全性，行业需要更多地使用威胁建模、安全设计模式和原则以及参考架构等。
> 5. **A05:2021 - 安全配置错误**：从 2017 年版的第 6 位上升至第 5 位，90% 的应用程序都针对某种形式的配置错误进行了测试。随着软件可配置性的提高，该类别风险上升，2017 年版中的 XML 外部实体（XXE）类别现也归为此类。
> 6. **A06:2021 - 易受攻击和过时的组件**：之前名为使用已知漏洞的组件，在社区调查中排名第 2，通过数据分析也足以进入前十，从 2017 年版的第 9 位上升至第 6 位，是一个较难测试和评估风险的已知问题，也是唯一没有将任何常见漏洞和暴露（CVE）映射到所包含 CWE 的类别，因此在评分时默认将其利用和影响权重设为 5.0。
> 7. **A07:2021 - 识别和认证失败**：之前为身份验证失效，从第 2 位下滑至第 7 位，现在包含了更多与识别失败相关的 CWE，虽排名有所下降，但仍是 Top 10 的重要组成部分，标准化框架的增加似乎对此有所帮助。
> 8. **A08:2021 - 软件和数据完整性故障**：2021 年新增类别，侧重于在未验证完整性的情况下，对软件更新、关键数据和 CI/CD 管道做出假设，与该类别中 10 个 CWE 对应的通用漏洞披露 / 通用漏洞评分系统（CVE/CVSS）数据影响权重较高，2017 年版的不安全反序列化现归为此大类。
> 9. **A09:2021 - 安全日志记录和监控故障**：由 2017 年版的不足的日志记录和监控扩展而来，从第 10 位上升至第 9 位，涵盖了更多类型的故障，虽难以测试且在 CVE/CVSS 数据中体现不足，但该类别故障会直接影响可见性、事件警报和取证。
> 10. **A10:2021 - 服务器端请求伪造**：通过 Top 10 社区调查新增的类别，数据显示其发生率相对较低，但测试覆盖率、利用和影响潜力的评级均高于平均水平，这表明安全社区认为其重要，即便当前数据未充分体现。

### 序列化和反序列化基础概念

**序列化：**是将变量转换为可保存或传输的字符串的过程；实现函数是serialize()

**反序列化：**把这个字符串再转化为原来的变量使用，就是序列化的逆过程，实现函数是unserialize()

**序列化数据格式：**

| 数据类型 | 序列化数据结构                                               |
| -------- | ------------------------------------------------------------ |
| 对象     | O:length:class name:attribute number:{attr1;vlaue1;attr2;value2;} |
| 字符串   | s:length:value;                                              |
| 整数     | i:value;                                                     |
| 布尔     | b:value;                                                     |
| 空值     | N;                                                           |
| 浮点数   | d:value;                                                     |

```php
<?php
class Student{
    public $name="marrio";
    public $grade=90;
}
$a=new Student;
var_dump($a);

?>
```

![image-20241218203621813](/img/ctfLearn/image-20241218203621813.png)

我们需要做的是把变量转化为字符串，这一步叫序列化

```php
<?php
class Student{
    public $name="marrio";
    public $grade=90;
}
$a=new Student;
var_dump($a);
echo serialize($a);
?>
```

![image-20241218204033339](/img/ctfLearn/image-20241218204033339.png)

**序列化以前：**

```
> object(Student)#1 (2) {
  ["name"]=>
  string(6) "marrio"
  ["grade"]=>
  int(90)
}
```

**序列化以后：**

```
O:7:"Student":2:{s:4:"name";s:6:"marrio";s:5:"grade";i:90;}
```

O代表对象，7代表长度length，对象名Student，属性个数为2

- 第一个属性的键是字符串，长度为4，名为name，值是长度为5的字符串，叫marrio
- 第二个属性的键是字符串，长度为5，名为grade，值是整数类型，是90

我们对序列化后的内容进行反序列化，就能回归到原来的状态

```php
<?php
class Student{
    public $name="marrio";
    public $grade=90;
}
$a=new Student;
var_dump($a);
echo serialize($a);
$b=unserialize(serialize($a));
echo "\n";
var_dump($b);
?>
```

![image-20241218204956134](/img/ctfLearn/image-20241218204956134.png)

**为什么要做序列化和反序列化：**

序列化和反序列化结合起来，可以轻松地存储和传输数据，使程序更具维护性。

就像网上买了一张桌子，淘宝卖家不会整张桌子，而是拆解成零件和说明书，根据说明书来组装。

### 反序列化漏洞

反序列化漏洞，也叫对象注入，就是当程序在进行反序列化时，会自动调用一些函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些*💀*恶意代码导函数中，从而导致反序列化漏洞。
